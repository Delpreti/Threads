\documentclass[12pt]{article}

\usepackage[brazilian]{babel}
% \usepackage[margin=1in]{geometry}
\usepackage{minted}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage[
backend=biber,
style=alphabetic,
sorting=ynt
]{biblatex}
\usepackage{csquotes}

\addbibresource{referencias.bib}
\DeclareMathOperator{\sha}{SHA256}

\author{Gabriel da Fonseca Ottoboni Pinho - DRE 119043838\\
Rodrigo Delpreti de Siqueira - DRE 119022353}
\title{Trabalho I de Computação Concorrente: \\Simulação de Mineração de Bitcoin}
\date{25/04/2021}

\begin{document}
\maketitle
\newpage

\section{Descrição do problema}
\subsection{Sobre a Bitcoin}
Bitcoin é uma criptomoeda criada por Satoshi Nakamoto em 2009,
tendo como objetivo ser uma moeda digital descentralizada.
Uma parte essencial da Bitcoin é uma tecnologia chamada \textit{Blockchain},
que consiste em armazenar todas as transações que já ocorreram
em blocos interligados.
Cada transação é criptograficamente assinada por seu emissor
e então enviada ao resto da rede,
que verifica a assinatura e a existência dos fundos.

Um ponto importante é que cada transação é verificada por todos,
de modo que nenhum integrante precisa confiar em nenhum outro,
cada um sendo capaz de verificar a verdade independentemente.
Os integrantes da rede que coletam as transações
e as colocam em blocos são os mineradores
e o sistema de consenso que determina qual minerador
terá o direito de criar o bloco se chama \textit{Proof of Work} (PoW).

A ideia da PoW é que o minerador que conseguir
a resposta de um desafio primeiro
tem o direito de criar o bloco.
Esse desafio consiste em achar um número \textit{nonce},
tal que quando o \textit{hash} SHA-256 do \textit{header} do bloco
(que contém a \textit{nonce})
seja menor que um número chamado de dificuldade.
Pelo fato do SHA-256 ser uma função \textit{hash} criptográfica,
a única forma de achar a \textit{nonce} correta é chutando.
Em outras palavas, não é possível achar um
$x$ tal que $\sha(x) = y$.
Por outro lado, tendo um $x$,
é fácil verificar se $\sha(x) = y$.
Essa propriedade é importante,
pois, dessa forma, todos os integrantes da rede podem
verificar facilmente se a \textit{nonce} encontrada
é uma solução válida de fato.

\subsection{Sobre o SHA-256}
O SHA-256 é uma função \textit{hash} criptográfica,
que gera uma sequência de 256 bits pseudo-aleatória
para uma entrada qualquer.
O cálculo dessa função é computacionalmente custoso,
e é o \textit{work} na PoW da Bitcoin.
O cálculo da função consiste em 3 passos principais:
\begin{enumerate}
	\item Pré-processamento
	\item Criação do array de mensagens
	\item Compressão
\end{enumerate}

Durante o pré-processamento,
a entrada é será divida em
pedaços chamados \textit{chunks} de 512 bits cada.
Depois disso, para cada \textit{chunk},
um array de 64 elementos de 4 bytes é
preenchido com base no conteúdo do \textit{chunk} atual.
Por fim, 8 variáveis são inicializadas com valores pré-determinados
que serão modificados em cada \textit{round} do loop de compressão.
O valor final do \textit{hash} será a concatenação das 8 variáveis.

\section{Projeto da solução concorrente}
O objetivo do nosso trabalho é
implementar o SHA-256 e
usá-lo para simular a mineração da Bitcoin.
Em outras palavras,
temos que receber como entrada
um número $d$ representando a dificuldade e
o número $n$ de threads a serem utilizados.
A saída será uma \textit{nonce} que
resolveria um bloco com essa dificuldade e
o tempo levado para calculá-la.
A dificuldade será o número de vezes seguidas 
que o byte \texttt{0x00} aparece no
início do \textit{hash} calculado.
Como foi explicado na sessão anterior,
não é exatamente assim que a dificuldade é definida
na implementação da Bitcoin,
mas foi decidido simplificar essa etapa.

A simulação funcionará da seguinte forma:
\begin{enumerate}
	\item 76 bytes aleatórios são gerados.
		Esses bytes representarão todos os campos
		do \textit{header} do bloco,
		exceto a \textit{nonce}.
	\item Cada thread calculará o \textit{hash} da concatenação
		desses mesmos 76 bytes com mais 4 bytes, a \textit{nonce}.
		Temos assim um total de 80 bytes,
		que é o tamanho real do \textit{header} de
		um bloco de Bitcoin.
	\item Se $\sha(\text{\textit{header}})$
		começar com pelo menos $d$ bytes \texttt{0x00} seguidos,
		conseguimos achar uma \textit{nonce} correta, fim.
		Senão, repetimos as etapas 2 e 3
		com uma \textit{nonce} diferente.
\end{enumerate}

É importante notar que cada tentativa
é completamente independente da outra, ou seja,
podemos facilmente acrescentar mais threads,
com cada uma testando diferentes valores para a \textit{nonce}
até que a resposta correta seja encontrada.
A estratégia utilizada foi
testar valores consecutivos para a \textit{nonce},
e distribuir esses números
entre as $n$ threads de $n$ em $n$.
Quando alguma das threads achar a resposta,
uma variável global \textit{flag} é setada
e as outras threads terminam.
A thread que encontrou a resposta
retorna seu valor para a thread principal,
que imprime os resultados na tela.

\section{Casos de teste}
A principal função do programa que
precisa ser testada é \texttt{sha256},
que recebe um sequência de bytes e
retorna uma string com o valor hexadecimal
do \textit{hash} SHA-256 da entrada.
Cada teste chama essa função com
valores de entrada pré-determinados e
compara o \textit{hash} retornado
com um valor correto pré-calculado.

\section{Avaliação de desempenho}

\section{Discussão}

\nocite{*}
\printbibliography

\end{document}
